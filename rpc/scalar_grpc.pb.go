// Code generated by protoc-gen-go-grpc. DO NOT EDIT.

package rpc

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// LedgerClient is the client API for Ledger service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type LedgerClient interface {
	RegisterContract(ctx context.Context, in *ContractRegistrationRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	ListContracts(ctx context.Context, in *ContractsListingRequest, opts ...grpc.CallOption) (*ContractsListingResponse, error)
	ExecuteContract(ctx context.Context, in *ContractExecutionRequest, opts ...grpc.CallOption) (*ContractExecutionResponse, error)
	ValidateLedger(ctx context.Context, in *LedgerValidationRequest, opts ...grpc.CallOption) (*LedgerValidationResponse, error)
	RetrieveAssetProof(ctx context.Context, in *AssetProofRetrievalRequest, opts ...grpc.CallOption) (*AssetProofRetrievalResponse, error)
	AbortExecution(ctx context.Context, in *ExecutionAbortRequest, opts ...grpc.CallOption) (*ExecutionAbortResponse, error)
}

type ledgerClient struct {
	cc grpc.ClientConnInterface
}

func NewLedgerClient(cc grpc.ClientConnInterface) LedgerClient {
	return &ledgerClient{cc}
}

func (c *ledgerClient) RegisterContract(ctx context.Context, in *ContractRegistrationRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/rpc.Ledger/RegisterContract", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ledgerClient) ListContracts(ctx context.Context, in *ContractsListingRequest, opts ...grpc.CallOption) (*ContractsListingResponse, error) {
	out := new(ContractsListingResponse)
	err := c.cc.Invoke(ctx, "/rpc.Ledger/ListContracts", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ledgerClient) ExecuteContract(ctx context.Context, in *ContractExecutionRequest, opts ...grpc.CallOption) (*ContractExecutionResponse, error) {
	out := new(ContractExecutionResponse)
	err := c.cc.Invoke(ctx, "/rpc.Ledger/ExecuteContract", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ledgerClient) ValidateLedger(ctx context.Context, in *LedgerValidationRequest, opts ...grpc.CallOption) (*LedgerValidationResponse, error) {
	out := new(LedgerValidationResponse)
	err := c.cc.Invoke(ctx, "/rpc.Ledger/ValidateLedger", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ledgerClient) RetrieveAssetProof(ctx context.Context, in *AssetProofRetrievalRequest, opts ...grpc.CallOption) (*AssetProofRetrievalResponse, error) {
	out := new(AssetProofRetrievalResponse)
	err := c.cc.Invoke(ctx, "/rpc.Ledger/RetrieveAssetProof", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ledgerClient) AbortExecution(ctx context.Context, in *ExecutionAbortRequest, opts ...grpc.CallOption) (*ExecutionAbortResponse, error) {
	out := new(ExecutionAbortResponse)
	err := c.cc.Invoke(ctx, "/rpc.Ledger/AbortExecution", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// LedgerServer is the server API for Ledger service.
// All implementations must embed UnimplementedLedgerServer
// for forward compatibility
type LedgerServer interface {
	RegisterContract(context.Context, *ContractRegistrationRequest) (*emptypb.Empty, error)
	ListContracts(context.Context, *ContractsListingRequest) (*ContractsListingResponse, error)
	ExecuteContract(context.Context, *ContractExecutionRequest) (*ContractExecutionResponse, error)
	ValidateLedger(context.Context, *LedgerValidationRequest) (*LedgerValidationResponse, error)
	RetrieveAssetProof(context.Context, *AssetProofRetrievalRequest) (*AssetProofRetrievalResponse, error)
	AbortExecution(context.Context, *ExecutionAbortRequest) (*ExecutionAbortResponse, error)
	mustEmbedUnimplementedLedgerServer()
}

// UnimplementedLedgerServer must be embedded to have forward compatible implementations.
type UnimplementedLedgerServer struct {
}

func (UnimplementedLedgerServer) RegisterContract(context.Context, *ContractRegistrationRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RegisterContract not implemented")
}
func (UnimplementedLedgerServer) ListContracts(context.Context, *ContractsListingRequest) (*ContractsListingResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListContracts not implemented")
}
func (UnimplementedLedgerServer) ExecuteContract(context.Context, *ContractExecutionRequest) (*ContractExecutionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ExecuteContract not implemented")
}
func (UnimplementedLedgerServer) ValidateLedger(context.Context, *LedgerValidationRequest) (*LedgerValidationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ValidateLedger not implemented")
}
func (UnimplementedLedgerServer) RetrieveAssetProof(context.Context, *AssetProofRetrievalRequest) (*AssetProofRetrievalResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RetrieveAssetProof not implemented")
}
func (UnimplementedLedgerServer) AbortExecution(context.Context, *ExecutionAbortRequest) (*ExecutionAbortResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AbortExecution not implemented")
}
func (UnimplementedLedgerServer) mustEmbedUnimplementedLedgerServer() {}

// UnsafeLedgerServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to LedgerServer will
// result in compilation errors.
type UnsafeLedgerServer interface {
	mustEmbedUnimplementedLedgerServer()
}

func RegisterLedgerServer(s grpc.ServiceRegistrar, srv LedgerServer) {
	s.RegisterService(&Ledger_ServiceDesc, srv)
}

func _Ledger_RegisterContract_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ContractRegistrationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LedgerServer).RegisterContract(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpc.Ledger/RegisterContract",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LedgerServer).RegisterContract(ctx, req.(*ContractRegistrationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Ledger_ListContracts_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ContractsListingRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LedgerServer).ListContracts(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpc.Ledger/ListContracts",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LedgerServer).ListContracts(ctx, req.(*ContractsListingRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Ledger_ExecuteContract_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ContractExecutionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LedgerServer).ExecuteContract(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpc.Ledger/ExecuteContract",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LedgerServer).ExecuteContract(ctx, req.(*ContractExecutionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Ledger_ValidateLedger_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LedgerValidationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LedgerServer).ValidateLedger(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpc.Ledger/ValidateLedger",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LedgerServer).ValidateLedger(ctx, req.(*LedgerValidationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Ledger_RetrieveAssetProof_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AssetProofRetrievalRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LedgerServer).RetrieveAssetProof(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpc.Ledger/RetrieveAssetProof",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LedgerServer).RetrieveAssetProof(ctx, req.(*AssetProofRetrievalRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Ledger_AbortExecution_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ExecutionAbortRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LedgerServer).AbortExecution(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpc.Ledger/AbortExecution",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LedgerServer).AbortExecution(ctx, req.(*ExecutionAbortRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Ledger_ServiceDesc is the grpc.ServiceDesc for Ledger service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Ledger_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "rpc.Ledger",
	HandlerType: (*LedgerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "RegisterContract",
			Handler:    _Ledger_RegisterContract_Handler,
		},
		{
			MethodName: "ListContracts",
			Handler:    _Ledger_ListContracts_Handler,
		},
		{
			MethodName: "ExecuteContract",
			Handler:    _Ledger_ExecuteContract_Handler,
		},
		{
			MethodName: "ValidateLedger",
			Handler:    _Ledger_ValidateLedger_Handler,
		},
		{
			MethodName: "RetrieveAssetProof",
			Handler:    _Ledger_RetrieveAssetProof_Handler,
		},
		{
			MethodName: "AbortExecution",
			Handler:    _Ledger_AbortExecution_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "scalar.proto",
}

// LedgerPrivilegedClient is the client API for LedgerPrivileged service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type LedgerPrivilegedClient interface {
	RegisterCert(ctx context.Context, in *CertificateRegistrationRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	RegisterFunction(ctx context.Context, in *FunctionRegistrationRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	RetrieveState(ctx context.Context, in *StateRetrievalRequest, opts ...grpc.CallOption) (*StateRetrievalResponse, error)
}

type ledgerPrivilegedClient struct {
	cc grpc.ClientConnInterface
}

func NewLedgerPrivilegedClient(cc grpc.ClientConnInterface) LedgerPrivilegedClient {
	return &ledgerPrivilegedClient{cc}
}

func (c *ledgerPrivilegedClient) RegisterCert(ctx context.Context, in *CertificateRegistrationRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/rpc.LedgerPrivileged/RegisterCert", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ledgerPrivilegedClient) RegisterFunction(ctx context.Context, in *FunctionRegistrationRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/rpc.LedgerPrivileged/RegisterFunction", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ledgerPrivilegedClient) RetrieveState(ctx context.Context, in *StateRetrievalRequest, opts ...grpc.CallOption) (*StateRetrievalResponse, error) {
	out := new(StateRetrievalResponse)
	err := c.cc.Invoke(ctx, "/rpc.LedgerPrivileged/RetrieveState", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// LedgerPrivilegedServer is the server API for LedgerPrivileged service.
// All implementations must embed UnimplementedLedgerPrivilegedServer
// for forward compatibility
type LedgerPrivilegedServer interface {
	RegisterCert(context.Context, *CertificateRegistrationRequest) (*emptypb.Empty, error)
	RegisterFunction(context.Context, *FunctionRegistrationRequest) (*emptypb.Empty, error)
	RetrieveState(context.Context, *StateRetrievalRequest) (*StateRetrievalResponse, error)
	mustEmbedUnimplementedLedgerPrivilegedServer()
}

// UnimplementedLedgerPrivilegedServer must be embedded to have forward compatible implementations.
type UnimplementedLedgerPrivilegedServer struct {
}

func (UnimplementedLedgerPrivilegedServer) RegisterCert(context.Context, *CertificateRegistrationRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RegisterCert not implemented")
}
func (UnimplementedLedgerPrivilegedServer) RegisterFunction(context.Context, *FunctionRegistrationRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RegisterFunction not implemented")
}
func (UnimplementedLedgerPrivilegedServer) RetrieveState(context.Context, *StateRetrievalRequest) (*StateRetrievalResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RetrieveState not implemented")
}
func (UnimplementedLedgerPrivilegedServer) mustEmbedUnimplementedLedgerPrivilegedServer() {}

// UnsafeLedgerPrivilegedServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to LedgerPrivilegedServer will
// result in compilation errors.
type UnsafeLedgerPrivilegedServer interface {
	mustEmbedUnimplementedLedgerPrivilegedServer()
}

func RegisterLedgerPrivilegedServer(s grpc.ServiceRegistrar, srv LedgerPrivilegedServer) {
	s.RegisterService(&LedgerPrivileged_ServiceDesc, srv)
}

func _LedgerPrivileged_RegisterCert_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CertificateRegistrationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LedgerPrivilegedServer).RegisterCert(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpc.LedgerPrivileged/RegisterCert",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LedgerPrivilegedServer).RegisterCert(ctx, req.(*CertificateRegistrationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LedgerPrivileged_RegisterFunction_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FunctionRegistrationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LedgerPrivilegedServer).RegisterFunction(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpc.LedgerPrivileged/RegisterFunction",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LedgerPrivilegedServer).RegisterFunction(ctx, req.(*FunctionRegistrationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LedgerPrivileged_RetrieveState_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StateRetrievalRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LedgerPrivilegedServer).RetrieveState(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpc.LedgerPrivileged/RetrieveState",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LedgerPrivilegedServer).RetrieveState(ctx, req.(*StateRetrievalRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// LedgerPrivileged_ServiceDesc is the grpc.ServiceDesc for LedgerPrivileged service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var LedgerPrivileged_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "rpc.LedgerPrivileged",
	HandlerType: (*LedgerPrivilegedServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "RegisterCert",
			Handler:    _LedgerPrivileged_RegisterCert_Handler,
		},
		{
			MethodName: "RegisterFunction",
			Handler:    _LedgerPrivileged_RegisterFunction_Handler,
		},
		{
			MethodName: "RetrieveState",
			Handler:    _LedgerPrivileged_RetrieveState_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "scalar.proto",
}

// AuditorClient is the client API for Auditor service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type AuditorClient interface {
	RegisterContract(ctx context.Context, in *ContractRegistrationRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	ListContracts(ctx context.Context, in *ContractsListingRequest, opts ...grpc.CallOption) (*ContractsListingResponse, error)
	OrderExecution(ctx context.Context, in *ContractExecutionRequest, opts ...grpc.CallOption) (*ExecutionOrderingResponse, error)
	ValidateExecution(ctx context.Context, in *ExecutionValidationRequest, opts ...grpc.CallOption) (*ContractExecutionResponse, error)
	ValidateLedger(ctx context.Context, in *LedgerValidationRequest, opts ...grpc.CallOption) (*LedgerValidationResponse, error)
}

type auditorClient struct {
	cc grpc.ClientConnInterface
}

func NewAuditorClient(cc grpc.ClientConnInterface) AuditorClient {
	return &auditorClient{cc}
}

func (c *auditorClient) RegisterContract(ctx context.Context, in *ContractRegistrationRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/rpc.Auditor/RegisterContract", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *auditorClient) ListContracts(ctx context.Context, in *ContractsListingRequest, opts ...grpc.CallOption) (*ContractsListingResponse, error) {
	out := new(ContractsListingResponse)
	err := c.cc.Invoke(ctx, "/rpc.Auditor/ListContracts", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *auditorClient) OrderExecution(ctx context.Context, in *ContractExecutionRequest, opts ...grpc.CallOption) (*ExecutionOrderingResponse, error) {
	out := new(ExecutionOrderingResponse)
	err := c.cc.Invoke(ctx, "/rpc.Auditor/OrderExecution", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *auditorClient) ValidateExecution(ctx context.Context, in *ExecutionValidationRequest, opts ...grpc.CallOption) (*ContractExecutionResponse, error) {
	out := new(ContractExecutionResponse)
	err := c.cc.Invoke(ctx, "/rpc.Auditor/ValidateExecution", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *auditorClient) ValidateLedger(ctx context.Context, in *LedgerValidationRequest, opts ...grpc.CallOption) (*LedgerValidationResponse, error) {
	out := new(LedgerValidationResponse)
	err := c.cc.Invoke(ctx, "/rpc.Auditor/ValidateLedger", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AuditorServer is the server API for Auditor service.
// All implementations must embed UnimplementedAuditorServer
// for forward compatibility
type AuditorServer interface {
	RegisterContract(context.Context, *ContractRegistrationRequest) (*emptypb.Empty, error)
	ListContracts(context.Context, *ContractsListingRequest) (*ContractsListingResponse, error)
	OrderExecution(context.Context, *ContractExecutionRequest) (*ExecutionOrderingResponse, error)
	ValidateExecution(context.Context, *ExecutionValidationRequest) (*ContractExecutionResponse, error)
	ValidateLedger(context.Context, *LedgerValidationRequest) (*LedgerValidationResponse, error)
	mustEmbedUnimplementedAuditorServer()
}

// UnimplementedAuditorServer must be embedded to have forward compatible implementations.
type UnimplementedAuditorServer struct {
}

func (UnimplementedAuditorServer) RegisterContract(context.Context, *ContractRegistrationRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RegisterContract not implemented")
}
func (UnimplementedAuditorServer) ListContracts(context.Context, *ContractsListingRequest) (*ContractsListingResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListContracts not implemented")
}
func (UnimplementedAuditorServer) OrderExecution(context.Context, *ContractExecutionRequest) (*ExecutionOrderingResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OrderExecution not implemented")
}
func (UnimplementedAuditorServer) ValidateExecution(context.Context, *ExecutionValidationRequest) (*ContractExecutionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ValidateExecution not implemented")
}
func (UnimplementedAuditorServer) ValidateLedger(context.Context, *LedgerValidationRequest) (*LedgerValidationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ValidateLedger not implemented")
}
func (UnimplementedAuditorServer) mustEmbedUnimplementedAuditorServer() {}

// UnsafeAuditorServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to AuditorServer will
// result in compilation errors.
type UnsafeAuditorServer interface {
	mustEmbedUnimplementedAuditorServer()
}

func RegisterAuditorServer(s grpc.ServiceRegistrar, srv AuditorServer) {
	s.RegisterService(&Auditor_ServiceDesc, srv)
}

func _Auditor_RegisterContract_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ContractRegistrationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuditorServer).RegisterContract(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpc.Auditor/RegisterContract",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuditorServer).RegisterContract(ctx, req.(*ContractRegistrationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Auditor_ListContracts_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ContractsListingRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuditorServer).ListContracts(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpc.Auditor/ListContracts",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuditorServer).ListContracts(ctx, req.(*ContractsListingRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Auditor_OrderExecution_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ContractExecutionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuditorServer).OrderExecution(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpc.Auditor/OrderExecution",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuditorServer).OrderExecution(ctx, req.(*ContractExecutionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Auditor_ValidateExecution_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ExecutionValidationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuditorServer).ValidateExecution(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpc.Auditor/ValidateExecution",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuditorServer).ValidateExecution(ctx, req.(*ExecutionValidationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Auditor_ValidateLedger_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LedgerValidationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuditorServer).ValidateLedger(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpc.Auditor/ValidateLedger",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuditorServer).ValidateLedger(ctx, req.(*LedgerValidationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Auditor_ServiceDesc is the grpc.ServiceDesc for Auditor service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Auditor_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "rpc.Auditor",
	HandlerType: (*AuditorServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "RegisterContract",
			Handler:    _Auditor_RegisterContract_Handler,
		},
		{
			MethodName: "ListContracts",
			Handler:    _Auditor_ListContracts_Handler,
		},
		{
			MethodName: "OrderExecution",
			Handler:    _Auditor_OrderExecution_Handler,
		},
		{
			MethodName: "ValidateExecution",
			Handler:    _Auditor_ValidateExecution_Handler,
		},
		{
			MethodName: "ValidateLedger",
			Handler:    _Auditor_ValidateLedger_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "scalar.proto",
}

// AuditorPrivilegedClient is the client API for AuditorPrivileged service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type AuditorPrivilegedClient interface {
	RegisterCert(ctx context.Context, in *CertificateRegistrationRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type auditorPrivilegedClient struct {
	cc grpc.ClientConnInterface
}

func NewAuditorPrivilegedClient(cc grpc.ClientConnInterface) AuditorPrivilegedClient {
	return &auditorPrivilegedClient{cc}
}

func (c *auditorPrivilegedClient) RegisterCert(ctx context.Context, in *CertificateRegistrationRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/rpc.AuditorPrivileged/RegisterCert", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AuditorPrivilegedServer is the server API for AuditorPrivileged service.
// All implementations must embed UnimplementedAuditorPrivilegedServer
// for forward compatibility
type AuditorPrivilegedServer interface {
	RegisterCert(context.Context, *CertificateRegistrationRequest) (*emptypb.Empty, error)
	mustEmbedUnimplementedAuditorPrivilegedServer()
}

// UnimplementedAuditorPrivilegedServer must be embedded to have forward compatible implementations.
type UnimplementedAuditorPrivilegedServer struct {
}

func (UnimplementedAuditorPrivilegedServer) RegisterCert(context.Context, *CertificateRegistrationRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RegisterCert not implemented")
}
func (UnimplementedAuditorPrivilegedServer) mustEmbedUnimplementedAuditorPrivilegedServer() {}

// UnsafeAuditorPrivilegedServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to AuditorPrivilegedServer will
// result in compilation errors.
type UnsafeAuditorPrivilegedServer interface {
	mustEmbedUnimplementedAuditorPrivilegedServer()
}

func RegisterAuditorPrivilegedServer(s grpc.ServiceRegistrar, srv AuditorPrivilegedServer) {
	s.RegisterService(&AuditorPrivileged_ServiceDesc, srv)
}

func _AuditorPrivileged_RegisterCert_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CertificateRegistrationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuditorPrivilegedServer).RegisterCert(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpc.AuditorPrivileged/RegisterCert",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuditorPrivilegedServer).RegisterCert(ctx, req.(*CertificateRegistrationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// AuditorPrivileged_ServiceDesc is the grpc.ServiceDesc for AuditorPrivileged service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var AuditorPrivileged_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "rpc.AuditorPrivileged",
	HandlerType: (*AuditorPrivilegedServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "RegisterCert",
			Handler:    _AuditorPrivileged_RegisterCert_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "scalar.proto",
}

// ProofRegistryClient is the client API for ProofRegistry service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ProofRegistryClient interface {
	RegisterProofs(ctx context.Context, in *ProofsRegistrationRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	RetrieveProof(ctx context.Context, in *ProofRetrievalRequest, opts ...grpc.CallOption) (*ProofRetrievalResponse, error)
}

type proofRegistryClient struct {
	cc grpc.ClientConnInterface
}

func NewProofRegistryClient(cc grpc.ClientConnInterface) ProofRegistryClient {
	return &proofRegistryClient{cc}
}

func (c *proofRegistryClient) RegisterProofs(ctx context.Context, in *ProofsRegistrationRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/rpc.ProofRegistry/RegisterProofs", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *proofRegistryClient) RetrieveProof(ctx context.Context, in *ProofRetrievalRequest, opts ...grpc.CallOption) (*ProofRetrievalResponse, error) {
	out := new(ProofRetrievalResponse)
	err := c.cc.Invoke(ctx, "/rpc.ProofRegistry/RetrieveProof", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ProofRegistryServer is the server API for ProofRegistry service.
// All implementations must embed UnimplementedProofRegistryServer
// for forward compatibility
type ProofRegistryServer interface {
	RegisterProofs(context.Context, *ProofsRegistrationRequest) (*emptypb.Empty, error)
	RetrieveProof(context.Context, *ProofRetrievalRequest) (*ProofRetrievalResponse, error)
	mustEmbedUnimplementedProofRegistryServer()
}

// UnimplementedProofRegistryServer must be embedded to have forward compatible implementations.
type UnimplementedProofRegistryServer struct {
}

func (UnimplementedProofRegistryServer) RegisterProofs(context.Context, *ProofsRegistrationRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RegisterProofs not implemented")
}
func (UnimplementedProofRegistryServer) RetrieveProof(context.Context, *ProofRetrievalRequest) (*ProofRetrievalResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RetrieveProof not implemented")
}
func (UnimplementedProofRegistryServer) mustEmbedUnimplementedProofRegistryServer() {}

// UnsafeProofRegistryServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ProofRegistryServer will
// result in compilation errors.
type UnsafeProofRegistryServer interface {
	mustEmbedUnimplementedProofRegistryServer()
}

func RegisterProofRegistryServer(s grpc.ServiceRegistrar, srv ProofRegistryServer) {
	s.RegisterService(&ProofRegistry_ServiceDesc, srv)
}

func _ProofRegistry_RegisterProofs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProofsRegistrationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProofRegistryServer).RegisterProofs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpc.ProofRegistry/RegisterProofs",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProofRegistryServer).RegisterProofs(ctx, req.(*ProofsRegistrationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProofRegistry_RetrieveProof_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProofRetrievalRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProofRegistryServer).RetrieveProof(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpc.ProofRegistry/RetrieveProof",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProofRegistryServer).RetrieveProof(ctx, req.(*ProofRetrievalRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// ProofRegistry_ServiceDesc is the grpc.ServiceDesc for ProofRegistry service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ProofRegistry_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "rpc.ProofRegistry",
	HandlerType: (*ProofRegistryServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "RegisterProofs",
			Handler:    _ProofRegistry_RegisterProofs_Handler,
		},
		{
			MethodName: "RetrieveProof",
			Handler:    _ProofRegistry_RetrieveProof_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "scalar.proto",
}

// ProxyClient is the client API for Proxy service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ProxyClient interface {
	RegisterCert(ctx context.Context, in *CertificateRegistrationRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	RegisterContract(ctx context.Context, in *ContractRegistrationRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	RegisterFunction(ctx context.Context, in *FunctionRegistrationRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	ExecuteContract(ctx context.Context, in *ContractExecutionRequest, opts ...grpc.CallOption) (*ContractExecutionResponse, error)
	ValidateLedgers(ctx context.Context, in *LedgersValidationRequest, opts ...grpc.CallOption) (*LedgersValidationResponse, error)
	ProxyResponse(ctx context.Context, in *IdentifiableResponse, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type proxyClient struct {
	cc grpc.ClientConnInterface
}

func NewProxyClient(cc grpc.ClientConnInterface) ProxyClient {
	return &proxyClient{cc}
}

func (c *proxyClient) RegisterCert(ctx context.Context, in *CertificateRegistrationRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/rpc.Proxy/RegisterCert", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *proxyClient) RegisterContract(ctx context.Context, in *ContractRegistrationRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/rpc.Proxy/RegisterContract", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *proxyClient) RegisterFunction(ctx context.Context, in *FunctionRegistrationRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/rpc.Proxy/RegisterFunction", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *proxyClient) ExecuteContract(ctx context.Context, in *ContractExecutionRequest, opts ...grpc.CallOption) (*ContractExecutionResponse, error) {
	out := new(ContractExecutionResponse)
	err := c.cc.Invoke(ctx, "/rpc.Proxy/ExecuteContract", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *proxyClient) ValidateLedgers(ctx context.Context, in *LedgersValidationRequest, opts ...grpc.CallOption) (*LedgersValidationResponse, error) {
	out := new(LedgersValidationResponse)
	err := c.cc.Invoke(ctx, "/rpc.Proxy/ValidateLedgers", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *proxyClient) ProxyResponse(ctx context.Context, in *IdentifiableResponse, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/rpc.Proxy/ProxyResponse", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ProxyServer is the server API for Proxy service.
// All implementations must embed UnimplementedProxyServer
// for forward compatibility
type ProxyServer interface {
	RegisterCert(context.Context, *CertificateRegistrationRequest) (*emptypb.Empty, error)
	RegisterContract(context.Context, *ContractRegistrationRequest) (*emptypb.Empty, error)
	RegisterFunction(context.Context, *FunctionRegistrationRequest) (*emptypb.Empty, error)
	ExecuteContract(context.Context, *ContractExecutionRequest) (*ContractExecutionResponse, error)
	ValidateLedgers(context.Context, *LedgersValidationRequest) (*LedgersValidationResponse, error)
	ProxyResponse(context.Context, *IdentifiableResponse) (*emptypb.Empty, error)
	mustEmbedUnimplementedProxyServer()
}

// UnimplementedProxyServer must be embedded to have forward compatible implementations.
type UnimplementedProxyServer struct {
}

func (UnimplementedProxyServer) RegisterCert(context.Context, *CertificateRegistrationRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RegisterCert not implemented")
}
func (UnimplementedProxyServer) RegisterContract(context.Context, *ContractRegistrationRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RegisterContract not implemented")
}
func (UnimplementedProxyServer) RegisterFunction(context.Context, *FunctionRegistrationRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RegisterFunction not implemented")
}
func (UnimplementedProxyServer) ExecuteContract(context.Context, *ContractExecutionRequest) (*ContractExecutionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ExecuteContract not implemented")
}
func (UnimplementedProxyServer) ValidateLedgers(context.Context, *LedgersValidationRequest) (*LedgersValidationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ValidateLedgers not implemented")
}
func (UnimplementedProxyServer) ProxyResponse(context.Context, *IdentifiableResponse) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ProxyResponse not implemented")
}
func (UnimplementedProxyServer) mustEmbedUnimplementedProxyServer() {}

// UnsafeProxyServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ProxyServer will
// result in compilation errors.
type UnsafeProxyServer interface {
	mustEmbedUnimplementedProxyServer()
}

func RegisterProxyServer(s grpc.ServiceRegistrar, srv ProxyServer) {
	s.RegisterService(&Proxy_ServiceDesc, srv)
}

func _Proxy_RegisterCert_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CertificateRegistrationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProxyServer).RegisterCert(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpc.Proxy/RegisterCert",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProxyServer).RegisterCert(ctx, req.(*CertificateRegistrationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Proxy_RegisterContract_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ContractRegistrationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProxyServer).RegisterContract(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpc.Proxy/RegisterContract",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProxyServer).RegisterContract(ctx, req.(*ContractRegistrationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Proxy_RegisterFunction_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FunctionRegistrationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProxyServer).RegisterFunction(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpc.Proxy/RegisterFunction",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProxyServer).RegisterFunction(ctx, req.(*FunctionRegistrationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Proxy_ExecuteContract_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ContractExecutionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProxyServer).ExecuteContract(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpc.Proxy/ExecuteContract",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProxyServer).ExecuteContract(ctx, req.(*ContractExecutionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Proxy_ValidateLedgers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LedgersValidationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProxyServer).ValidateLedgers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpc.Proxy/ValidateLedgers",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProxyServer).ValidateLedgers(ctx, req.(*LedgersValidationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Proxy_ProxyResponse_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IdentifiableResponse)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProxyServer).ProxyResponse(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpc.Proxy/ProxyResponse",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProxyServer).ProxyResponse(ctx, req.(*IdentifiableResponse))
	}
	return interceptor(ctx, in, info, handler)
}

// Proxy_ServiceDesc is the grpc.ServiceDesc for Proxy service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Proxy_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "rpc.Proxy",
	HandlerType: (*ProxyServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "RegisterCert",
			Handler:    _Proxy_RegisterCert_Handler,
		},
		{
			MethodName: "RegisterContract",
			Handler:    _Proxy_RegisterContract_Handler,
		},
		{
			MethodName: "RegisterFunction",
			Handler:    _Proxy_RegisterFunction_Handler,
		},
		{
			MethodName: "ExecuteContract",
			Handler:    _Proxy_ExecuteContract_Handler,
		},
		{
			MethodName: "ValidateLedgers",
			Handler:    _Proxy_ValidateLedgers_Handler,
		},
		{
			MethodName: "ProxyResponse",
			Handler:    _Proxy_ProxyResponse_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "scalar.proto",
}
